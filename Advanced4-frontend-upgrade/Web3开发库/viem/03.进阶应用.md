# Viem 进阶应用指南

## 3.1 智能合约交互
### 类型安全 ABI 集成
```typescript
// 使用 const 断言锁定 ABI 类型
const erc20Abi = [
  {
    name: 'balanceOf',
    type: 'function',
    stateMutability: 'view',
    inputs: [{ name: 'owner', type: 'address' }],
    outputs: [{ type: 'uint256' }]
  }
] as const // 必须使用 as const 保证类型推断

// 自动推断返回类型为 bigint
const balance: bigint = await client.readContract({
  address: '0x...',
  abi: erc20Abi,
  functionName: 'balanceOf',
  args: ['0x...']
})
```

### 多链合约调用
```typescript
// 配置多链客户端
const clients = {
  mainnet: createPublicClient({ chain: mainnet, transport: http() }),
  polygon: createPublicClient({ chain: polygon, transport: http() })
}

// 并行获取多链数据
const [ethBalance, maticBalance] = await Promise.all([
  clients.mainnet.readContract({/* mainnet 参数 */}),
  clients.polygon.readContract({/* polygon 参数 */})
])
```

### 事件过滤监听
```typescript
// 精确过滤 Transfer 事件
const unwatch = client.watchContractEvent({
  address: '0x...',
  abi: erc20Abi,
  eventName: 'Transfer',
  args: {
    from: '0x...' // 只监听特定地址的转账
  },
  onLogs: logs => {
    console.log('Filtered transfers:', logs)
  }
})

// 带区块范围的事件查询
const historicLogs = await client.getContractEvents({
  fromBlock: 100000n,
  toBlock: 'latest'
})
```

## 3.2 前端集成
### React 集成模式
```typescript
// lib/viem.ts
import { createPublicClient, http } from 'viem'
import { mainnet } from 'viem/chains'

export function useViemClient() {
  const [blockNumber, setBlockNumber] = useState<bigint>()

  useEffect(() => {
    const client = createPublicClient({
      chain: mainnet,
      transport: http()
    })
    
    const unwatch = client.watchBlockNumber({
      onBlockNumber: num => setBlockNumber(num)
    })
    
    return () => unwatch()
  }, [])

  return { blockNumber }
}
```

### Next.js 服务端组件
```typescript
// app/page.tsx
import { createPublicClient } from 'viem'

export default async function Home() {
  const client = createPublicClient({/* 配置 */})
  const block = await client.getBlock()

  return (
    <ClientComponent 
      blockNumber={block.number.toString()}
      timestamp={block.timestamp.toString()} 
    />
  )
}

// 客户端组件
function ClientComponent({ blockNumber }: { blockNumber: string }) {
  return <div>Current Block: {blockNumber}</div>
}
```

### 响应式状态管理
```typescript
// stores/contractStore.ts
import { create } from 'zustand'

type ContractState = {
  balance: bigint
  refresh: () => Promise<void>
}

export const useContractStore = create<ContractState>((set) => ({
  balance: 0n,
  refresh: async () => {
    const newBalance = await client.readContract({/* 读操作 */})
    set({ balance: newBalance })
  }
}))
```

## 关键功能验证
1. ABI 类型检查：尝试修改函数参数类型观察TS报错
2. 多链调用：在不同链客户端执行相同合约方法
3. 服务端数据流：在Next.js组件观察hydration警告处理
4. 状态更新：修改合约数据后触发UI自动刷新

推荐调试工具：
- TS类型检查：VSCode 类型悬停提示
- 网络请求查看：Alchemy 的 Mempool 可视化
- 状态监控：React DevTools 状态树
